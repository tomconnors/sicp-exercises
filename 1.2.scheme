;;; Exercise 1.11
;; Recursive Solution:
(define (f n)
  (if (< n 3)
      n
      (+
       (f (- n 1))
       (* 2 (f (- n 2)))
       (* 3 (f (- n 3))))))

;; Iterative Solution is very hard.

;;; Exercise 1.12
;;    1
;;   1 1
;;  1 2 1
;; 1 3 3 1
;;1 4 6 4 1
;; The value at pascal row, column is equal to the value at
;; pascal (row-1), (column-1) + pascal(row-1), column.
;; when a row or column is zero, its value is 1
(define (pascal row column)
  (if (or (= 0 row)
          (= 0 column)
          (= column row))
      1
      (+ (pascal (- row 1) (- column 1))
         (pascal (- row 1) column))))

(= (pascal 0 0) 1)
(= (pascal 1 0) 1)
(= (pascal 2 1) 2)
(= (pascal 3 2) 3)
(= (pascal 4 2) 6)

;; Change 10 cents using only pennies and nickels:
;; All ways to change ten using only pennies: 1 way: 10 pennies
;; All ways to change ten - nickel amnt using nickels and pennies:
;;   All ways to change 5 using nickels and pennies:
;;     All ways to change 5 using only pennies: 1 way: 5 pennies
;;     All ways to change 5-nickel amnt using both:
;;       amnt=0, counts as 1.
;; So there's 3 possible ways.

;;; Exercise 1.16
;; define an iterative version of fast-expt (fast exponentiation)

(define (expt b n)
  (cond ((= n 0) 1)
        ((even? n) (square (expt b (/ n 2))))
        (else (* b (expt b (- n 1))))))

(define (fast-expt b n)
  (fast-expt-iter b n 1))

(define (even? n)
  (= (remainder n 2) 0))

;; ab^n

;; 2^2
;; 1 * 2 ^ 2 === 4
;; 1 * 4 ^ 1

;; b^1 * b^n-1
;;

;; 3^3
;; 3 3 1
;; 1 * 3^3 = 27
;; 3 * 3^2 = 27

;; 5^5
;; 5 5 1
;; 5 4 5
;; 25 2 5
;; 625 1 5
;; 625 0 3125
(define (fast-expt-iter b n a)
  (cond ((= n 0) a)
        ((even? n) (fast-expt-iter (square b) (/ n 2) a))
        ;; QUESTION: how were we supposed to 'see' that we could use
        ;; (* a b) ?  Is that a mathematical simplification that I
        ;; just didn't notice?
        (else (fast-expt-iter b (- n 1) (* a b)))))

;; 1.22
;; hmm: (runtime) doesn't appear to work correctly in my
;; implementation of scheme - it's almost always 0
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (next input)
  (if (= input 2)
      3
      (+ input 2)))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (search-for-primes min max)
  (if (< min max)
      (test+recur min max)))

(define (test+recur min max)
  (timed-prime-test min)
  (search-for-primes (+ 1 min) max))

;; exercise 1.25
;; replacing expmod
;; original fn:
(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m)) m))
        (else
         (remainder (* base (expmod base (- exp 1) m)) m))))

(expmod 8 2 5)
(remainder (square (expmod 8 (/ 2 2) 5)) 5)
(remainder (square (expmod 8 1 5)) 5)
(remainder (square (remainder (* 8 (expmod 8 0 5)) 5)) 5)
(remainder (square (remainder 8 5)) 5)
(remainder (square 3) 5)
(remainder 9 5)
4

;; new:
(define (expmod base exp m)
  (remainder (fast-expt base exp) m))

(expmod 2 4 5)

;; alyssa's function seems to work just as well as the original.
;; ah, but it is slow.
;; it is slower than the original implementation because, while the
;; original implementation used successive squaring while halving the
;; exponent, the new implementation calculates the entire exponential
;; at once. The exponential gets big very quickly (exponentially, in
;; fact), so the numbers are more costly for the interpreter to work
;; with.

;; exercise 1.26
;; Louis's code is O(n) instead of O(log n) because he calls expmod
;; twice whenever the exponent is even.
;; why O(log n) -> O(n) though? Why those values, specifically?

;; exercise 1.27
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (inc n) (+ 1 n))

;; carmichael numbers passed to this fn will return #t, indicating
;; that they are prime numbers, when in fact they are not.
(define (carmichael-test n)
  (define (carmichael-test* a)
    (if (>= a n)
        true
        (and (= a (expmod a n n))
             (carmichael-test* (inc a)))))
  (carmichael-test* 1))

;; exercise 1.28
;; Miller-Rabin test

(define (r-m-test n)
  (define (try-it a)
    ))

;; Exercise 1.29
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (simpson-integral f a b n)
  (define h (/ (- b a) n))
  (define (next x) (+ x 1))
  (define (y k)
    (f (+ a (* h k))))
  (define (term k)
    (* (cond ((odd? k) 4)
             ((or (= k 0) (= k n)) 1)
             ((even? k) 2))
       (y k)))
  (/ (* h (sum term 0 next n)) 3))

;; Exercise 1.30
;; iterative sum
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter (next a) (term a)))

(define (identity a) a)
(define (inc x) (+ x 1))

;; Exercise 1.31
;; a
;; define product as a hof
(define (product term a next b)
  (if (> a b)
      1
      (* (term a) (product term (next a) next b))))
;; define factorial in terms of product
(define (factorial n)
  (product identity 1 inc n))
;; approximate pi using product
(define (pi n)
  (define (term x)
    (if (even? x)
        (/ (+ 2 x) (inc x))
        (/ (inc x) (+ 2 x))))
  (* 4 (product term 1.0 inc n)))
;; b: now iteratively
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1))

;; Exercise 1.32
;; show sum and product are just special cases of a more general
;; notion; accumulate
(define (accumulate combiner null-value term a next b)
  (if (> a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))
(define (sum term a next b)
  (accumulate + 0 term a next b))
(define (product term a next b)
  (accumulate * 1 term a next b))

;; accumulate, iteratively
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a)
              (combiner (term a) result))))
  (iter a null-value))


;; Exercise 1.33
(define (filtered-accumulate combiner keep? null-value term a next b)
  (define term-a (term a))
  (if (> a b)
      null-value
      (combiner (if (keep? a) term-a null-value)
                (filtered-accumulate combiner keep? null-value term (next a) next b))))


(define (sum-of-squares-of-primes-in-range a b)
  (filtered-accumulate + prime? 0 square a inc b))

(define (gcd x y)
  (define (iter val maxi)
    (if (> val (max x y))
        maxi
        (if (= 0 (remainder x val) (remainder y val))
            (iter (inc val) val)
            (iter (inc val) maxi))))
  (iter 1 1))

(define (product-of-lesser-relative-primes n)
  (define (relatively-prime-to-n? x)
    (= 1 (gcd n x)))
  (filtered-accumulate * relatively-prime-to-n? 1 identity 1 inc n))

;; Exercise 1.34
;; The interpretter will eventually try to call 2 as a function, which it is not, resulting in a runtime error

;; Exercise 1.35
;; Show that the golden ratio is a fixed point of the transformation
;; x -> 1 + 1/x, and compute the golden ratio using the fixed point procedure
;;
;; (golden ^ 2) = golden + 1
;; golden = g
;; g^2 = g + 1
;; g = (g+1)/g
;; g = (1)/g + g/g
;; g = 1 + 1/g

(define (transform x) (+ 1 (/ 1 x)))
(transform (transform (transform 4)))

(define tolerance .0000001)

(define golden-ratio (fixed-point transform 1.0))

(define (fixed-point f guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try guess))

;; Exercise 1.36
;; Add printing to fixed-point
(define (fixed-point f guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (newline)
    (display guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try guess))
;; Find solution to x^x = 1000
;; using fixed-point of x-> log(1000) / log(x)
(fixed-point (lambda (x) (/ (log 1000) (log x)))
             2)
;; Now with average damping
(define (average-damp f)
  (lambda (y) (average y (f y))))

(define (average x y) (/ (+ x y) 2))

(fixed-point (average-damp (lambda (x) (/ (log 1000) (log x))))
             2)
;; The average-dampened solution converges much more quickly!

;; Exercise 1.37
;; a. continued fractions to estimate 1/golden-ratio
(define (inc i) (+ i 1))
(define (cont-frac n d k)
  (define (next y)
    (if (>= y k)
        (/ (n y) (d y))
        (/ (n y)
           (+ (d y) (next (inc y))))))
  (next 1))
;; estimates 1/golden-ratio correct to four decimal places at
;; k=13.
;; Oddly enough, the calculation is exactly equal to the golden ratio
;; calculated using fixed-point (as above) when k=15
;; I wonder if this is more than coincidence.
;; b. cont-frac using an iterative process
;; The trick is to iterate by decrementing, rather than by incrementing
(define (dec i) (- i 1))
(define (cont-frac-iter n d k)
  (define (next y val)
    (if (<= y 1)
        (/ (n y)
           (+ val (d y)))
        (next (dec y)
              (/ (n y)
                 (+ val (d y))))))
  (next k 0))

;; Exercise 1.38
;; estimate e using cont-frac
(define (d x) (if (= 0 (remainder (- x 2) 3))
                  (+ 2 (* (/ (- x 2) 3) 2))
                  1))
(define e
  (+ 2 (cont-frac (lambda (x) 1.0)
                  d
                  50)))

;; Exercise 1.39
;; tangent function using continued fractions
;; tan x = x / (1 - (x^2 / (3 - (x^2 / (5 - ...))))
;;       = x / (1 + (-(x^2)) / (3 + (-(x^2) / 5 + ...)))
(define (square x) (* x x))
(define (nth-odd n)
  (- (* 2 n) 1))
(define (tan-cf x k)
  (cont-frac (lambda (y) (if (= y 1)
                             1.0
                             (* -1 (square x))))
             nth-odd
             k))

;; Exercise 1.40
;; cubic using newton's method
;; I don't understand the math behind this well enough to
;; Know whether my cubic function is correct
(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))
(define dx 0.00001)
(define (newton-transform g)
  (lambda (x)
    (- x (/ ( g x) ((deriv g) x)))))
(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x))
                  1.0))
(define (cube x) (* x x x))
(define (cubic a b c)
  (lambda (x)
    (+ (cube x) (* a (square x)) (* b x) c)))

;; Exercise 1.41
(define (inc x) (+ x 1))
(define (double g)
  (lambda (x) (g (g x))))

;; Exercise 1.42
;; define compose
(define (compose f g)
  (lambda (x) (f (g x))))

;; Exercise 1.43
;; define repeated such that ((repeated square 2) 5) => 625
(define (repeated f n)
  (define (fn x y)
    (if (> y 0)
        (fn (f x) (- y 1))
        x))
  (lambda (x)
    (fn x n)))
;; repeated using compose:
(define (repeated f n)
  (if (> n 1)
      (compose f (repeated f (- n 1)))
      f))

;; Exercise 1.44
;; smoothing functions
(define dx 0.00001)
;; I don't know how to handle variadic functions in scheme, so
;; I have to do this!
(define (average x y z)
  (/ (+ x y z) 3))
(define (smooth f)
  (lambda (x)
    (average (f (- x dx)) (f x) (f (+ x dx)))))
;; smooth repeatedly
(define (dec x) (- x 1))
(define (n-fold-smoothed f n)
  (if (> n 0)
      (n-fold-smoothed (smooth f) (dec n))
      f))
;; using repeated
(define (n-fold-smoothed f n)
  ((repeated smooth n) f))
;; Bill the Lizard's implementation looked like:
(define (n-fold-smoothed f n)
  (repeated (smooth f) n))
;; His appears to be wrong. Smoothing `inc` should always
;; just return the normal incremented value, but his doesn't.
;; What gives?

;; Exercise 1.45
;; nth-root searches with repeated average damping
;; Here's the example with square-roots:
(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
(define (cube-root x)
  (fixed-point  (average-damp (lambda (y) (/ x (square y))))
                1.0))
;; This one will not converge:
(define (fourth-root x)
  (fixed-point  (average-damp (lambda (y) (/ x (cube y))))
                1.0))
(define (cube x) (* x x x))
;; But by adding more average damping, it does converge:
(define (fourth-root x)
  (fixed-point  (average-damp (average-damp (lambda (y) (/ x (cube y)))))
                1.0))
;; create an nth-root procedure.
(define (nth-root x n)
  (define (find-repeats x y)
    (if (>= (expt 2 y) x)
        y
        (find-repeats x (inc y))))
  (fixed-point ((repeated average-damp (find-repeats x 1))
                (lambda (y) (/ x (expt y (- n 1)))))
               1.0))
;; I struggled with the above because I was trying to do:
(repeated (average-damp (lambda (y) (/ x (expt y (- n 1)))))
          n)
;; Which does not work, because it average damps the function, then
;; repeatedly applied that function to itself, rather than repeatedly
;; applying average damping. I need to think more about that, I'm sort
;; of confused.

;; Exercise 1.46
;; Iterative improvement
(define (iterative-improve good-enough? improve)
  (define (iter guess)
    (if (good-enough? guess)
        guess
        (iter (improve guess))))
  iter)
(define (average x y) (/ (+ x y) 2))
(define (square x) (* x x))
(define (sqrt x)
  (define (improve guess)
    (average guess (/ x guess)))
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.0001))
  ((iterative-improve good-enough? improve) 1))
(define tolerance 0.00001)
(define (fixed-point f)
  (define (good-enough? guess)
    (< (abs (- guess (improve guess))) tolerance))
  (define (improve guess)
    (f guess))
  ((iterative-improve good-enough? improve) 1.0))


;;; CHAPTER 2

;; Exercise 2.1
;; a better make-rat
(define (opp n) (* -1 n))
(define (make-rat n d)
  (cond
   ((and (negative? n) (negative? d)) (cons (opp n) (opp d)))
   ((negative? d) (cons (opp n) (opp d)))
   (else (cons n d))))

;; Exercise 2.2
;; defining segments and points
(define (make-segment p1 p2)
  (cons p1 p2))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (midpoint-segment seg)
  (make-point (/ (+ (x-point (start-segment seg)) (x-point (end-segment seg)))
                 2)
              (/ (+ (y-point (start-segment seg)) (y-point (end-segment seg)))
                 2)))

;; Exercsie 2.3
;; representing rectangles in a plane
(define (make-rect x-origin y-origin width height)
  (let ((origin (make-point x-origin y-origin)))
    (cons origin (cons width height))))
(define (rect-origin r)
  (car r))
(define (rect-height r)
  (cdr (cdr r)))
(define (rect-width r)
  (car (cdr r)))

(define (rect-area r)
  (* (rect-height r) (rect-width r)))
(define (rect-perim r)
  (+ (* 2 (rect-width r)) (* 2 (rect-height r))))

;; Now represent rectangles differently.
(define (make-rect left-x top-y right-x bottom-y)
  (cons left-x (cons top-y (cons right-x bottom-y))))
(define (rect-left-x r)
  (car r))
(define (rect-right-x r)
  (car (cdr (cdr r))))
(define (rect-top-y r)
  (car (cdr r)))
(define (rect-bottom-y r)
  (cdr (cdr (cdr r))))

(define (rect-height r)
  (- (rect-bottom-y r) (rect-top-y r)))
(define (rect-width r)
  (- (rect-right-x r) (rect-left-x r)))

;; Exercise 2.4
;; represent pairs as procedures
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (x y) x)))
(define (cdr z)
  (z (lambda (x y) y)))

;; Exercise 2.5
;; represent pairs of non-negative numbers
(define (cons-num a b)
  (* (expt 2 a) (expt 3 b)))
(define (car-num z)
  (count-divisions z 2))
(define (cdr-num z)
  (count-divisions z 3))
(define (inc i) (+ 1 i))
;; I feel very dumb for needing this function. Isn't there some very
;; basic math that does what this function does?
(define (count-divisions n x)
  (define (count-divisions-iter n i)
    (if (integer? (/ n x))
        (count-divisions-iter (/ n x) (inc i))
        i))
  (count-divisions-iter n 0))

;; Exercise 2.6
;; Define one, two, and + in terms of procedures
(define zero (lambda (f) (lambda (x) x)))
(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
;; (add-1 zero) =>
(lambda (f)
  (lambda (x)
    (f (((lambda (g)
           (lambda (y) y))
         f)
        x))))
(lambda (f)
  (lambda (x)
    (f ((lambda (y) y)
        x))))
(lambda (f)
  (lambda (x)
    (f x)))
;; (add-1 'the-value-above-this)
(add-1 (lambda (f)
         (lambda (x)
           (f x))))
(lambda (f)
  (lambda (x)
    (f (f x))))
;; so it looks like each add-1 wraps the initial x in another call to f
;; define one
(define one (lambda (f)
              (lambda (x)
                (f x))))
(define two (lambda (f)
              (lambda (x)
                (f (f x)))))
(define (add n m)
  (lambda (f)
    (lambda (x)
      ((m f) ((n f) x)))))

;; Exercise 2.7
(define  (make-interval a b) (cons a b))
(define (lower-bound interval)
  (car interval))
(define (upper-bound interval)
  (cdr interval))
;; Exericse 2.8
(define (sub-interval a b)
  (make-interval (- (lower-bound a) (lower-bound b))
                 (- (upper-bound a) (upper-bound b))))

(define (add-interval a b)
  (make-interval (+ (lower-bound a) (lower-bound b))
                 (+ (upper-bound a) (upper-bound b))))

;; Exercise 2.9
(define (interval-width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
;; The width of the result of subtraction appears to be (- (width a) (width b))
;; The width of the multiple of two intervals is not a function of the
;; width of the two intervals, as shown by:
(define (mul-interval a b)
  (let ((p1 (* (lower-bound a) (lower-bound b)))
        (p2 (* (lower-bound a) (upper-bound b)))
        (p3 (* (upper-bound a) (lower-bound b)))
        (p4 (* (upper-bound a) (upper-bound b))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
;; We define three intervals a,b,c, all with a width of one.
;; We multiply a * b, and find the width of that, w1
;; We multiple b * c, and find the width of that, w2
;; If w1 != w2, the width of the multiple is not a function
;; of the width of the intervals being multiplied.
(define interval-a (make-interval 1 3))
(define interval-b (make-interval 2 4))
(define interval-c (make-interval 3 5))
(= 1
   (interval-width interval-a)
   (interval-width interval-b)
   (interval-width interval-c)) ;; = #t
(= (interval-width (mul-interval interval-a interval-b))
   (interval-width (mul-interval interval-b interval-c))) ;; = #f

;; Exercise 2.10
;; Modify interval code to handle division by zero errors
(define (div-interval x y)
  (if (and (>= (upper-bound y) 0)
           (<= (lower-bound y) 0))
      (error "Cannot divide by an interval that spans zero")
      (mul-interval x (make-interval (/ 1.0 (upper-bound y))
                                     (/ 1.0 (lower-bound y))))))

;; Exercise 2.11
;; I GOT THIS ONE WRONG
;; More efficient interval multiplication
;; possible cases:
;; all numbers are non-negative
;; all numbers but lower-x are non-negative
;; all numbers but lower-y are non-negative
;; lower numbers are negative and upper numbers are non-negative
;; upper-x is non-negative, the rest are negative
;; upper-y is non-negative, the rest are negative
;; all numbers are negative
;; both upper-bounds are zero
;; both lower-bounds are zero
(define (mul-interval x y)
  (let ((ux (positive? (upper-bound x)))
        (uy (positive? (upper-bound y)))
        (lx (positive? (lower-bound x)))
        (ly (positive? (lower-bound y))))
    (cond
     ((and lx ly) (make-interval (* (lower-bound x) (lower-bound y))
                                 (* (upper-bound x) (upper-bound y))))
     ((and ly ux (not lx)) (make-interval (* (lower-bound x) (upper-bound y))
                                          (* (upper-bound x) (upper-bound y))))
     ((and lx up (lot ly)) (make-interval (* (lower-bound y) (upper-bound x))
                                          (* (upper-bound x) (upper-bound y))))
     ((and ux uy (not ly) (not lx))
      (make-interval (* (if (< (lower-bound x) (lower-bound y))
                            (lower-bound x)
                            (lower-bound y))
                        (if (< (lower-bound x) (lower-bound y))
                            (upper-bound y)
                            (upper-bound x)))
                     (* (upper-bound x) (upper-bound y))))
     ((and ux (not uy) (not lx))
      (make-interval (* (upper-bound x) (lower-bound y))
                     (* (upper-bound y) (lower-bound x))))
     ((and uy (not ux) (not ly))
      (make-interval (* (upper-bound y) (lower-bound x))
                     (* (upper-bound x) (lower-bound y))))
     ((and (not ux) (not uy))
      (let ((lx*ly (* (lower-bound x) (lower-bound y)))
            (lx*uy (* (lower-bound x) (upper-bound y)))
            (ux*ly (* (upper-bound x) (lower-bound y)))
            (ux*uy (* (upper-bound x) (upper-bound y)))))
      (make-interval (min lx*ly lx*uy ux*ly ux*uy)
                     (max lx*ly lx*uy ux*ly ux*uy))))))

;; Exercise 2.12
;; Intervals from center point and width as percentage
(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))

(define (make-center-percent c p)
  (make-interval (- c (* c p)) (+ c (* c p))))
(define (percent i)
  (/ (- (upper-bound i) (center i))
     (center i)))

;; Exercise 2.13
;; Formula for estimating the percentage tolerance of the multiple of
;; two intervals
;; This solution is fairly accurate for low percentages (< .10)
(define (estimated-tolerance-of-multiple x y)
  (+ (percentage x) (percentage y)))

;; Exercise 2.14
;; First verify the problem exists:
(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval one
                  (add-interval (div-interval one r1)
                                (div-interval one r2)))))
(define A (make-center-percent 10 .0000001))
(define B (make-center-percent 9 .01))
(center (div-interval a a))
(percent (div-interval a a))
;; The result of A/A should be an interval centered at one, with a percent of zero.
;; Because of some inaccuracy of the representation, this is not the result, and the
;; error is greater with larger initial percents.

;; Exercise 2.15
;; is par2 better than par1?
;; The reasoning is that a procedure that uses fewer instances of values
;; with an uncertainty will be more accurate.
;; This seems logical, as r1 and r2 (the args to par1 and par2) are
;; used twice each in par1 and only once each in par2.
;; The interval `one` is used multiple times in par2, but because this is the
;; interval from 1 to 1, it has no uncertainty.
;; My lingering concern is that par2 uses more procedures to calculate intervals,
;; all of which may introduce more uncertainty/error.

;; Exercise 2.17
;; last-pair
(define  (last-pair l)
  (if (null? (cdr l))
      l
      (last-pair (cdr l))))

;; Exercise 2.18
;; reverse
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))

(define (reverse l)
  (define (reverse-iter l coll)
    (if (null? l)
        coll
        (reverse-iter (cdr l) (cons (car l) coll))))
  (reverse-iter l '()))

;; Exercise 2.19
;; order of coin-values does not matter.
(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
(define (first-denomination coins) (car coins))
(define (except-first-denomination coins) (cdr coins))
(define (no-more? coins) (null? coins))

;; Exercise 2.20
;; rest args!
(define (same-parity x . y)
  (let ((parity-check (if (even? x) even? odd?)))
    (define (parity-check-list l)
      (if (null? l)
          l
          (if (parity-check (car l))
              (cons (car l) (parity-check-list (cdr l)))
              (parity-check-list (cdr l)))))
    (cons x (parity-check-list y))))

;; Exercise 2.21
;; mapping!
(define (square-list items)
  (if (null? items)
      items
      (cons (square (car items))
            (square-list (cdr items)))))

(define (square-list items)
  (map square items))

;; Exercise 2.22
;; iterative square-list
;; louis' first implementation is backward because
;; he is cons'ing the first result onto the empty list, then
;; the next result onto that, until the list is exhausted,
;; thereby building up the list in reverse order.
;; His second attempt doesn't work because each time he is cons'ing the
;; answer - a list - onto the next result - a number.
;; This we create deeper and deeper nesting as the process executes.
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              ;; something like this?
              ;; would need to define concat.
              (concat answer (square (car things))))))
  (iter items '()))

;; Exercise 2.23
;; for-each
(define (for-each fun items)
  (if (null? items)
      true
      (let ((first (car items)))
        (fun first)
        (for-each fun (cdr items)))))

;; Exercise 2.24
;; what is the result of (list 1 (list 2 (list 3 4)))
;; given by the interpretter?
;; (1 (2 (3 4)))
;; box and pointer structure?
;; [[][]]
;;  | |
;;  v v
;;  1 [[][]]
;;     | |
;;     v v
;;     2 [[][]]
;;        | |
;;        v v
;;        3 [[][]]
;;           | |
;;           v v
;;           4 /
;; As a tree?
;;   .
;;  / \
;; 1  .
;;    /\
;;   2 .
;;     /\
;;    3 4

;; Exercise 2.25
;; get 7 from these lists:
;; a)
(let ((l '(1 3 (5 7) 9)))
  (car (cdr (car (cdr (cdr l))))))
;; b)
(let ((l '((7))))
  (car (car l)))
;; c)
(let ((l '(1 (2 (3 (4 (5 (6 7))))))))
  (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr l)))))))))))))

;; Exercise 2.26
(define x (list 1 2 3))
(define y (list 4 5 6))
;; what is (append x y)?
;; (1 2 3 4 5 6)
;; what is (cons x y)
;; ((1 2 3) 4 5 6)
;; what is (list x y)
;; ((1 2 3) (4 5 6))
(append x y)
(cons x y)
(list x y)

;; Exercise 2.27
(define (deep-reverse l)
  (cond ((null? l) l)
        ((pair? (car l))
         (append (deep-reverse (cdr l))
                 (list (deep-reverse (car l)))))
        (else (append (deep-reverse (cdr l))
                      (list (car l))))))

;; Exercise 2.28
(define (fringe x)
  (cond
   ((null? x) x)
   ((pair? x) (append (fringe (car x)) (fringe (cdr x))))
   (else (list x))))

;; Should be on page 170 (at least) by end of August

;; Exercise 2.29
;; binary mobiles
(define (make-mobile left right)
  (list left right))
(define (make-branch length structure)
  (list length structure))

;; a:
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (car (cdr mobile)))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (car (cdr branch)))

;; b:
(define (mobile? weight-or-mobile)
  (pair? weight-or-mobile))

;; An improvement that can be made: extract `branch-weight`
;; That way we can use branch weight again in `branch-torque`
(define (total-weight mobile)
  (define (total-branch-weight branch)
    (let ((weight-or-mobile (branch-structure branch)))
      (if (mobile? weight-or-mobile)
          (total-weight weight-or-mobile)
          weight-or-mobile)))
  (+ (total-branch-weight (left-branch mobile))
     (total-branch-weight (right-branch mobile))))

(= 20 (total-weight
       (make-mobile
        (make-branch 3
                     (make-mobile (make-branch 3 5) (make-branch 4 5)))
        (make-branch 2
                     (make-mobile (make-branch 3 5) (make-branch 4 5))))))

;; c:
(define (torque length weight)
  (* length weight))

(define (branch-torque branch)
  (let ((weight-or-mobile (branch-structure branch)))
    (torque (branch-length branch)
            (if (mobile? weight-or-mobile)
                (total-weight weight-or-mobile)
                weight-or-mobile))))

(define (branch-balanced? branch)
  (let ((weight-or-mobile (branch-structure branch)))
    (if (mobile? weight-or-mobile)
        (balanced? weight-or-mobile)
        #t)))

(define (balanced? mobile)
  (let ((left-torque (branch-torque (left-branch mobile)))
        (right-torque (branch-torque (right-branch mobile))))
    (and (= left-torque right-torque)
         (branch-balanced? (left-branch mobile))
         (branch-balanced? (right-branch mobile)))))

(balanced?
 (make-mobile
  (make-branch 6 (make-mobile (make-branch 1 1) (make-branch 1 1)))
  (make-branch 3 4)))

(balanced? (make-mobile (make-branch 1 1) (make-branch 1 1)))

;; d:
;; change constructors
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
;; This forces selectors to change:
;; (just the ones that depend on the cdr being a list, rather than just an item)
(define (right-branch mobile)
  (cdr mobile))
(define (branch-structure branch)
  (cdr branch))

;; Exercise 2.30
;; square-tree
(define (square-tree tree)
  (cond ((null? tree) tree)
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))

(define (square-tree tree)
  (map (lambda (t)
         (if (pair? t)
             (square-tree t)
             (square t)))
       tree))

;; Exercise 2.31
(define (tree-map f tree)
  (map (lambda (t)
         (if (pair? t)
             (tree-map f t)
             (f t)))
       tree))

(define (square-tree tree) (tree-map square tree))

;; Exercise 2.32
;; subsets
;; Why it works:
;; for each list, it first finds all the subsets of the tail
;; of the list. This bottoms out at an empty list.
;; After that, it maps over the results of finding all the
;; tail-subsets, and cons's the first item to that -
;; So first it cdrs down the list in calls to subsets.
;; This bottoms out at the empty list.
;; Then, with just the last item in the original list,
;; it maps over the previous result (a list with just the empty list in it)
;; and cons's the last element of the original list onto it, then
;; appends the result of that map to the previous result.
;; This is hard to explain, but I get it.
(define (subsets s)
  (if (null? s)
      (list s)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (item)
                            (cons (car s) item))
                          rest)))))

;; Exercise 2.33
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(define (inc i) (+ 1 i))
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) '() sequence))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (item memo) (inc memo)) 0 sequence))

;; Exercise 2.34
;; horner's rule
;; 1 + 3x + 5x^3 + x^5 @ x=2 == (horner-eval 2 (list 1 3 0 5 0 1))
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ (* x higher-terms) this-coeff))
              0
              coefficient-sequence))

;; Exercise 2.35
;; count-leaves using accumulate
(define (count-leaves t)
  (accumulate + 0 (map (lambda (t)
                         (if (pair? t)
                             (count-leaves t)
                             1))
                       t)))
;; Can use enumerate-tree to shorten the solution:
(define (enumerate-tree tree)
   (cond ((null? tree) tree)
         ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                       (enumerate-tree (cdr tree))))))
(define (count-leaves t)
  (accumulate + 0 (map (lambda (t) 1)
                       (enumerate-tree t))))

;; Exercise 2.36
(define nil '())
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

;; Exercise 2.37
(define (dot-product v w)
  (accumulate + 0 (map * v w)))
(define (matrix-*-vector m v)
  (map (lambda (vec) (dot-product v vec)) m))
;; transpose [[1 2 3][4 5 6][7 8 9]] == [[1 4 7][2 5 8][3 6 9]]
(define (transpose mat)
  (accumulate-n cons '() mat))
;; (matrix-*-matrix '((1 2 3) (4 5 6)) '((7 8) (9 10) (11 12)))
;; => '((58 64) (139 154))
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (vec)
           (map (lambda (vec2)
                  (dot-product vec vec2))
                cols))
         m)))

;; Exercise 2.38
;; The way I picture fold-right actually seems more like a left-moving
;; process...
;; You get a list: (a b c d)
;; Then something that involves the last element: (a b c [d])
;; Then the last + the next to last element: (a b [c d])
;; and so on: (a [b c d]) , ([a b c d]) == result
;; And fold-left is the opposite:
;; (a b c d) => ([a] b c d) => ([a b] c d) => ([a b c] d) => ([a b c d]) == result
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(define fold-right accumulate)
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(fold-right / 1 (list 1 2 3)) ;; = (1 / (2 / (3 / 1))) == 3/2
(fold-left / 1 (list 1 2 3)) ;; = (((1/1)/2)/3) == 1/6
(fold-right list nil (list 1 2 3)) ;; = (((3) 2) 1) <- WRONG - fold-right passes in the first of the sequence as the FIRST argument when op is called.
(fold-left list nil (list 1 2 3)) ;; (list (list () 1) 2).. => (((() 1) 2) 3)
;; In order for fold-left and fold-right to produce the same result,
;; op should return the same value for the same arguments, regardless
;; of the order of the arguments. For instance, + produces the
;; same result for both:
(fold-left + 1 (list 1 2 3))
(fold-right + 1 (list 1 2 3))

;; Exercise 2.39
;; What really seems to matter for me to remember about fold-left
;; and fold-right is the order of arguments to the passed in operation.
;; Also the ordering which the list is iterated.
;; For fold-right/accumulate:
;; the operation is called with the first item in the list
;;  and the result of folding the rest of the list.
;; For fold-left:
;; the operation is called with the result and the first of the list.
(define (reverse sequence)
  (fold-right (lambda (x y) (append y (list x))) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) (cons y x)) nil sequence))

;; Exercise 2.40
(define (inc i) (+ i 1))
(define (dec i) (- i 1))
(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
(define nil '())
(define (enumerate-interval min max)
  (if (> min max)
      nil
      (cons min (enumerate-interval (inc min) max))))
(define (unique-pairs n)
  (flatmap
   (lambda (i)
     (map
      (lambda (j)
        (list i j))
      (enumerate-interval 1 (dec i))))
   (enumerate-interval 1 n)))
(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (unique-pairs n))))

;; Exercise 2.41
(define (ordered-triples-sum n s)
  (filter
   (lambda (triple)
     (= s (+ (car triple) (cadr triple) (caddr triple))))
   (flatmap
    (lambda (i)
      (flatmap
       (lambda (j)
         (map (lambda (k) (list i j k))
              (enumerate-interval 1 (dec j))))
       (enumerate-interval 1 (dec i))))
    (enumerate-interval 1 n))))

;; Exercise 2.42
;; eight queens problem
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
(define empty-board '())
(define (adjoin-position row col board)
  (cons (list row col) board))
(define (row pos)
  (car pos))
(define (col pos)
  (cadr pos))
(define (safe? column board-positions)
  (if (<= (length board-positions) 1)
      true
      (let ((new-pos (car board-positions)))
        (null? (filter
                (lambda (position)
                  (or (= (row new-pos) (row position))
                      (= (abs (- (row new-pos) (row position)))
                         (abs (- (col new-pos) (col position))))))
                (cdr board-positions))))))

;; Exercise 2.43
;; Louis' code is slow because it calculates the result for k-1 once for every
;; row/column pair, rather than once for just every column - I think this makes
;; the solution exponential. So if the original solution runs in 2 seconds, the
;; bad one runs in 4.

;; Exercise 2.44
;; up-split
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))

;; Exercise 2.45
;; general splitting
;; upper and lower are bad names. What are better names?
(define (split upper lower)
  (define (split-inner painter n)
    (if (= n 0)
        painter
        (let ((smaller (split-inner painter (- n 1))))
          (upper painter (lower smaller smaller)))))
  split-inner)

;; Exercise 2.46
;; vectors!
(define (make-vect x y)
  (list x y))
(define (xcor-vect v)
  (car v))
(define (ycor-vect v)
  (cadr v))
(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1) (xcor-vect v2))
             (+ (ycor-vect v1) (ycor-vect v2))))
(define (sub-vect v1 v2)
  (make-vect (- (xcor-vect v1) (xcor-vect v2))
             (- (ycor-vect v1) (ycor-vect v2))))
(define (scale-vect scale v)
  (make-vect (* scale (xcor-vect v))
             (* scale (ycor-vect v))))

;; Exercise 2.47
;; frame constructors
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (origin-frame frame)
  (car frame))
(define (edge1-frame frame)
  (cadr frame))
(define (edge2-frame frame)
  (caddr frame))
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
(define (origin-frame frame)
  (car frame))
(define (edge1-frame frame)
  (cadr frame))
(define (edge2-frame frame)
  (cddr frame))

;; Exercise 2.48
;; segments
(define (make-segment start end)
  (cons start end))
(define (start-segment seg)
  (car seg))
(define (end-segment seg)
  (cdr seg))

;; Exercise 2.49
;; defining painters
(define (segments->painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame) (start-segment segment))
        ((frame-coord-map frame) (end-segment segment))))
     segment-list)))

;; draws outline of frame
(define (sum vals) (reduce + 0 vals))
(define (average . vals)
  (/ (sum vals) (length vals)))
(define (antiorigin-frame frame)
  (make-vect (+ (xcor-vect (origin-frame frame))
                  (+ (xcor-vect (edge1-frame frame))
                     (xcor-vect (edge2-frame frame))))
               (+ (ycor-vect (origin-frame frame))
                  (+ (ycor-vect (edge1-frame frame))
                     (ycor-vect (edge2-frame frame))))))

(define origin-vect (make-vect 0 0))
;; bill the lizard (all hail) says we should use .99 rather than
;; 1, which makes sense - the frame is 1 unit wide and starts at 0,
;; so 1 is the very very edge of it, and things drawn there won't be visible.
(define edge1-vect (make-vect 1 0))
(define edge2-vect (make-vect 0 1))
(define antiorigin-vect (make-vect 1 1))

(define (frame-painter frame)
  ((segments->painter
    (list
     ;; origin -> edge 2
     (make-segment origin-vect edge2-vect)
     ;; origin ->edge 1
     (make-segment origin-vect edge1-vect)
     ;; edge1 -> antiorigin
     (make-segment edge1-vect antiorigin-vect)
     ;; edge2 -> antiorigin
     (make-segment edge2-vect antiorigin-vect)))
   frame))
(define (x-painter frame)
  ((segments->painter
    (list
     ;; origin to antiorigin
     (make-segment origin-vect antiorigin-vect)
     ;; edge1 to edge2
     (make-segment edge1-vect edge2-vect)))
   frame))
(define (divide-vect vect n)
  (scale-vect (/ 1 n) vect))
(define (avg-vect . vecs)
  (divide-vect (reduce add-vect (make-vect 0 0) vecs)
               (length vecs)))
(define (diamond-painter frame)
  ;; first need the midpoints
  (let ((mid-origin-edge1 (avg-vect origin-vect edge1-vect))
        (mid-edge1-antiorigin (avg-vect edge1-vect antiorigin-vect))
        (mid-antiorigin-edge2 (avg-vect antiorigin-vect edge2-vect))
        (mid-edge2-origin (avg-vect edge2-vect origin-vect)))
    ((segments->painter
      (list
       (make-segment mid-origin-edge1 mid-edge1-antiorigin)
       (make-segment mid-edge1-antiorigin mid-antiorigin-edge2)
       (make-segment mid-antiorigin-edge2 mid-edge2-origin)
       (make-segment mid-edge2-origin mid-origin-edge1)))
     frame)))
(define (wave-painter frame)
  ;;jesus
  ;; I'm not doing this one.
  ;; It's exactly what you'd expect, just a ton of segments
  ;; describing each line of the figure.
  )

;; Exercise 2.50
(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))
(define (flip-horiz painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
(define (rotate-270 painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)
                     (make-vect 0.0 0.0)
                     (make-vect 1.0 1.0)))
(define (rotate-180 painter)
  (transform-painter painter
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 1.0)
                     (make-vect 1.0 0.0)))

;; Exercise 2.51
;; define below in two ways:
;; one analogous to beside,
;; and one using beside
(define (below painter1 painter2)
  (let ((split-point (make-vect 0.0 0.5)))
    (let ((paint-bottom
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              (make-vect 1.0 0.0)
                              split-point))
          (paint-top
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.0)
                              (make-vect 0.0 1.0))))
      (lambda (frame)
        (paint-bottom frame)
        (paint-top frame)))))
;; define in terms of beside
;; i want to rotate each painter 90 degrees,
;; then draw them beside each other
;; then rotate that composite back 90 deg the other way.
(define (below painter1 painter2)
  (rotate-270
   (beside
    (rotate-90 painter1)
    (rotate-90 painter2))))
